<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Lounge</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" type="text/css">
    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="stylesheet" href="css/cayman.css">
    <link rel="stylesheet" href="css/prism.css">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Lounge</h1>
      <h2 class="project-tagline">Simple Mongoose-inspired ODM for Couchbase</h2><a href="https://github.com/bojand/lounge" target="_blank" class="btn">View on GitHub</a><a href="https://npmjs.com/package/lounge" target="_blank" class="btn">View on npm</a>
    </section>
    <section data-spy="scroll" data-target=".scrollspy" class="main-content">
      <div class="row">
        <div class="col-md-3 col-xs-3 bs-docs-sidebar">
          <ul id="sidebar" class="nav nav-stacked fixed">
            <li class="active"><a href="index.html">Main
                <ul class="nav nav-stacked">
                </ul></a></li>
            <li><a href="couchdoc.js.html">couchdoc.js</a></li>
            <li><a href="document.js.html">document.js</a></li>
            <li><a href="driver.js.html">driver.js</a></li>
            <li><a href="index.js.html">index.js</a></li>
            <li><a href="model.js.html">model.js</a></li>
            <li><a href="schema.js.html">schema.js</a></li>
            <li><a href="tree.js.html">tree.js</a></li>
            <li><a href="type.js.html">type.js</a></li>
            <li><a href="utils.js.html">utils.js</a></li>
          </ul>
        </div>
        <div class="col-md-9">
          <section id="Main" class="readme"><h1>Lounge</h1>
<p>Simple Mongoose-inspired ODM for <a href="http://www.couchbase.com">Couchbase</a>.</p>
<h2>Installation</h2>
<p><code>npm install lounge</code></p>
<h2>Stability</h2>
<p>This module is under development and there could be bugs. API may not be 100% locked down.
Documentation is still work in progress.</p>
<h2>Overview</h2>
<p>Lounge is a simple, somewhat opinionated, Mongoose-inspired ODM for <a href="http://www.couchbase.com">Couchbase</a>. Main goal is
to provide modeling tool framework for working with Couchbase databases in an asynchronous environment of Node.js.</p>
<pre><code class="language-js">var lounge = require('lounge');
lounge.connect({ 
  connectionString: 'couchbase://127.0.0.1',
  bucket: 'lounge_test'
});

var schema = lounge.schema({ name: String });
var Cat = lounge.model('Cat', schema);

var kitty = new Cat({ name: 'Zildjian' });
kitty.save(function (err) {
  if (err) // ...
  console.log('meow');
});
</code></pre>
<h5>Features:</h5>
<ul>
<li>Schema definition</li>
<li>Strict modelling based on schema</li>
<li>Schema extension</li>
<li>Automatic type validation and custom validation</li>
<li>Document upsert and removal</li>
<li>Embedded (referenced) documents</li>
<li>Automatic and manual population of embedded (referenced) document</li>
<li>Middleware including pre and post hooks</li>
<li>Indexing using <a href="http://docs.couchbase.com/developer/dev-guide-3.0/lookups.html">reference lookup documents</a></li>
</ul>
<h5>Outside of the scope of this module:</h5>
<ul>
<li>Document and view management. There are too many patterns and ways of performing document and view management and
view lookup that it is impractical to accommodate anything sane within a simple ODM. This can easily be expanded
on top of Lounge.</li>
<li>View queries. For same reasons this falls outside of the scope of Lounge.</li>
<li>Automatic document removal on key change. That is if a document key property changes, the new document is saved under
the new key. The old document sticks around under the old key. There are too many implications if we start automatically
handle document removal in this scenario. This should be handled by the user of this module.</li>
</ul>
<h2>Guide</h2>
<ul>
<li><a href="#lounge">Setup</a></li>
<li><a href="#model">Modelling</a></li>
<li><a href="#middleware">Middleware</a></li>
<li><a href="#schema-extend">Schema Extension</a></li>
<li><a href="#embedded">Embedded Documents</a></li>
<li><a href="#saving">Saving Documents</a></li>
<li><a href="#removing">Removing Documents</a></li>
<li><a href="#population">Population</a></li>
<li><a href="#indexes">Indexes</a></li>
<li><a href="#queries">Queries</a></li>
<li><a href="#events">Events</a></li>
<li><a href="#apidocs">API Documentation</a></li>
</ul>
<h3>Setup <a id="lounge"></a></h3>
<pre><code class="language-js">var lounge = require('lounge');
</code></pre>
<p>Module exports an instance of <code>Lounge</code> class.</p>
<h4>Lounge(options)</h4>
<p>Creates a new instance of <code>Lounge</code> class. You rarely have to do this.</p>
<pre><code class="language-js">var lounge = require('lounge');
var l = new lounge.Lounge();
</code></pre>
<p><strong>Options</strong></p>
<ul>
<li><code>keyPrefix</code> - key prefix for all keys. No default. Generally useful if you wish to namespace documents.
Example: <code>app::env::</code>.</li>
<li><code>storeFullReferenceId</code> - whether to store embedded document keys as fully expanded keys
(with prefix and suffix applied) or just the minimized version. default: <code>false</code>.</li>
<li><code>storeFullKey</code> - Similarly, to store the fully expanded document key inside the key property. default: <code>false</code></li>
<li><code>alwaysReturnArrays</code> - set to true to force <code>findyById</code> to always return an array of documents even if only
a single key is passed in. Default: <code>false</code></li>
<li><code>refIndexKeyPrefix</code> - reference lookup index document key prefix. The name of the index is appended to this.
Default: <code>'$_ref_by_'</code></li>
<li><code>delimiter</code> - delimiter string used for concatenation in reference document key expansion / generation. default: <code>'_'</code>
This is prepended to the reference document key.</li>
<li><code>waitForIndex</code> - When documents are saved, indexes are updated. We can wait for this operation to finish before
returning from <code>save()</code>. Default: <code>false</code></li>
<li><code>minimize</code> - &quot;minimize&quot; schemas by removing empty objects. Default: <code>true</code></li>
</ul>
<p>Any of these options, or additional variables can be manipulated using the <code>setOption</code> and <code>getOption</code> methods.</p>
<pre><code class="language-js">var lounge = require('lounge');
lounge.setOption('alwaysReturnArrays', true);
console.log(lounge.getOption('alwaysReturnArrays');
</code></pre>
<h4>Lounge.connect(options, fn, mock)</h4>
<p>Connects to the database cluster based on <code>options</code>. When completed calls <code>fn</code> callback. Set <code>mock</code> to <code>true</code> to use
<a href="https://github.com/couchbase/couchnode#mock-testing">Couchbase mocking</a>. Alternatively you can set
<code>LOUNGE_COUCHBASE_MOCK</code> environment variable. Returns an instance of Couchbase <code>bucket</code>.</p>
<p><strong>Options</strong></p>
<ul>
<li><code>connectionString</code> - connection string for the cluster. See <a href="http://docs.couchbase.com/sdk-api/couchbase-node-client-2.1.2/Cluster.html">Cluster documentation</a>.</li>
<li><code>bucket</code> - name of the bucket to be used for <a href="http://docs.couchbase.com/sdk-api/couchbase-node-client-2.1.2/Cluster.html#openBucket"><code>openBucket</code></a>
or the actual, already connected, Couchbase <code>bucket</code> instance.</li>
<li><code>password</code> - password for <a href="http://docs.couchbase.com/sdk-api/couchbase-node-client-2.1.2/Cluster.html#openBucket"><code>openBucket</code></a></li>
<li><code>certpath</code> - certpath for <a href="http://docs.couchbase.com/sdk-api/couchbase-node-client-2.1.2/Cluster.html">cluster constructor</a>.</li>
</ul>
<pre><code class="language-js">var lounge = require('lounge');
var bucket = lounge.connect({ 
  connectionString: 'couchbase://127.0.0.1',
  bucket: 'lounge_test'
}, function(err, bucket) {
  // ... connected
});
</code></pre>
<h4>Lounge.disconnect()</h4>
<p>Disconnect from the bucket. Deletes all defined models.</p>
<h4>Lounge.schema(descriptor, options)</h4>
<p>Creates a new <code>Schema</code> based on <code>descriptor</code> and <code>options</code>. Prefer this over the actual <code>Schema</code> constructor as this
will pass lounge config variables to the <code>Schema</code> constructor automatically.</p>
<p>Schema construction options:</p>
<ul>
<li><code>keyPrefix</code> - key prefix for all keys. No default. Generally useful if you wish to namespace documents. Example: <code>app::env::</code>.</li>
<li><code>keySuffix</code> - Similar as prefix but used as a suffix</li>
<li><code>refIndexKeyPrefix</code> - reference lookup index document key prefix. The name of the index is appended. Default: '$<em>ref_by</em>'
Reference / lookup document keys are also treated using <code>keyPrefix</code> and <code>keySuffix</code> settings.</li>
<li><code>delimiter</code> - delimiter string used for concatenation in reference document key expansion / generation.
Default: '_'. This is prepended to the reference document key.</li>
<li><code>minimize</code> - &quot;minimize&quot; schemas by removing empty objects. Default: <code>true</code></li>
<li><code>toObject</code> - toObject method options: <code>transform</code>, <code>virtuals</code> and <code>minimize</code></li>
<li><code>toJSON</code> - toJSON method options, similar to above</li>
<li><code>strict</code> - ensures that value passed in ot assigned that were not specified in our schema do not get saved. Default: <code>true</code></li>
</ul>
<h4>Lounge.model(name, schema, options)</h4>
<p>Defines a Model based on case sensitive model <code>name</code> and created <code>schema</code>, with given options. From there we can create
instances of the Model;</p>
<p><strong>Options</strong></p>
<ul>
<li><code>freeze</code> - to freeze the model. See <code>Object.freeze</code>. Default: <code>true</code></li>
</ul>
<pre><code class="language-js">var userSchema = lounge.schema({
  firstName: String,
  lastName: String,
  email: String,
  dateOfBirth: Date,
});

User = lounge.model('User', userSchema);
var user = new User({
  firstName: 'Joe',
  lastName: 'Smith',
  email: 'joe@gmail.com',
  dateOfBirth: new Date()
});

console.log(user instanceof User) // true
</code></pre>
<h4>Lounge.modelNames()</h4>
<p>Returns and array of all defined model names.</p>
<h4>Bucket functions</h4>
<p>Lounge instance also inherits all public <a href="http://docs.couchbase.com/sdk-api/couchbase-node-client-2.1.2/Bucket.html"><code>Bucket</code></a>
functions and properties.</p>
<pre><code class="language-js">lounge.get('mydocumentkey', function(err, res) {
  // .. save as if we did normal bucket.get()
});
</code></pre>
<h4>Lounge.Schema</h4>
<p>Exported <code>Schema</code> constructor. You can use this as well as <code>lounge.schema()</code>, which is preferred.</p>
<pre><code class="language-js">var userSchema = new lounge.Schema({ name: String });
</code></pre>
<h4>Lounge.Model</h4>
<p>Exported <code>Model</code> constructor. You should never have to manually create a Model.</p>
<h4>Lounge.Document</h4>
<p>Exported  internal <code>Document</code> constructor. You should never have to manually create a Document.</p>
<pre><code class="language-js">// already defined User model
var user = new User({name: 'Bob'});
console.log(user instanceof User) // true
console.log(user instanceof lounge.Model) // true
console.log(user instanceof lounge.Document) // true
</code></pre>
<h3>Modelling <a id="model"></a></h3>
<p><strong>Basics</strong></p>
<p>We begin defining a data model using a schema.</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  firstName: String,
  lastName: String,
  age: Number,
  usernames: [String],
  setup: Boolean
  metadata: {
    createdAt: Date,
    updatedAt: Date
  }
});
</code></pre>
<p>We can add additional properties using <code>add</code> function:</p>
<pre><code class="language-js">userSchema.add('name', String);
</code></pre>
<p>Alternatively we can explicitly specify the type using <code>type</code> property:</p>
<pre><code class="language-js">var catSchema = lounge.schema({
  name: { type: String }
  breed: String,
});

catSchema.add('age', {type: String});
</code></pre>
<p>Schema options can be set at construction or using the <code>set</code> function.</p>
<pre><code class="language-js">var catSchema = lounge.schema({
  name: { type: String }
  breed: String,
}, {
  keyPrefix: 'cat::'
});

catSchema.set('refIndexKeyPrefix', '::');
</code></pre>
<p><strong>Document keys</strong></p>
<p>By default schemas come with an <code>id</code> property as the document key, and the automatically generated value will be
a <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>
using <a href="https://www.npmjs.com/package/node-uuid">node-uuid</a> <code>v4()</code> function. This should be most practical and
appropriate in a lot of cases. Alternatively you can specify explicit key properties:</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  firstName: String,
  lastName: String,
  email: { type: String, key: true, generate: false }
});
</code></pre>
<p>Here we desire <code>email</code> to be used as the document key and we specify <code>generate: false</code> because we do not want Lounge
to automatically handle key property value generation. If we still want uuid generation but in a different property
we can specify so:</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  firstName: String,
  lastName: String,
  email: String,
  userId: {type: String, key: true, generate: true }
});
</code></pre>
<p><code>generate</code> does not have to be set explicitly to <code>true</code> as that is the default.</p>
<p>We can specify additional prefix and/or suffix for keys. This will be used when wrigin to the database as the actual
document key.</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  firstName: String,
  lastName: String,
  email: { type: String, key: true, generate: false, prefix: 'user'}
});
</code></pre>
<p>Note that setting prefix and suffix options like this will take presidence over any <code>keyPrefix</code> and <code>keySuffix</code>
options specified in the second options parameter to the <code>schema()</code> call or any settings in the lounge config.</p>
<p><strong>Examples</strong></p>
<pre><code class="language-js">var lounge = require('lounge');

// ... connect

var userSchema = lounge.schema({
  name: String
  email: { type: String, key: true, generate: false, prefix: 'user::'}
});

var User = lounge.model('User', userSchema);
var user = new User({name: 'Bob Smith', email: 'bsmith@acme.com'});
user.save();
</code></pre>
<p>This will save the user document under key <code>user::bsmith@acme.com</code>.</p>
<pre><code class="language-js">var lounge = require('lounge');

// ... connect

var userSchema = lounge.schema({
  name: String
}, {
  keyPrefix: 'user::'
});

var User = lounge.model('User', userSchema);
var user = new User({name: 'Bob Smith'});
user.save();
</code></pre>
<p>This will automatically generate a uuid <code>id</code> property and save the user document under key
similar to <code>user::110ec58a-a0f2-4ac4-8393-c866d813b8d1</code>.</p>
<p><strong>Data manipulation</strong></p>
<p>Data in Model instances can be access directly or using <code>get</code> function. Similarly it can be manipulated using
either assignment operator or using the <code>set</code> function. In either case the input value is validated to be of proper type.</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  name: String
  friends: Number,
  dob: Date,
  setup: Boolean
});

var User = lounge.model('User', userSchema);
var user = new User({name: 'Bob Smith'});

user.get('name'); // 'Bob Smith'
user.name = 'Joe'; // OK
user.name.set('Joe'); // OK
console.log(user.name); // 'Joe'
user.set('friends', 20); // OK
user.friends = 'abc'; // nope. still 20
user.dob = new Date('July 5, 1980');
user.get('dob'); // instance of Date
user.set('setup', 'yup'); // nope
user.setup = true; // OK
</code></pre>
<p><strong>Validation</strong></p>
<p>Lounge does automatic validation against input data using the type information specified in the schema definition.
We can provide custom validation in schema definition by providing <code>validator</code> function.</p>
<pre><code class="language-js">var validator = require('validator'); // Node validator module

var userSchema = lounge.schema({
  name: String
  email: {type: String, validator: validator.isEmail}
});

var User = lounge.model('User', userSchema);
var user = new User({ name: 'Bob Smith' });

user.email = 'bob@gmail.com'; // OK
user.email = 'bsmith'; // Nope
console.log(user.email); // 'bob@gmail.com'
</code></pre>
<p><strong>Virtuals</strong></p>
<p>Virtuals are document properties that you can get and set but that do not get persisted to the database.
The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value
into multiple values for storage.</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  firstName: String, 
  lastName: String
});

userSchema.virtual('fullName', {
  get: function () {
    return this.firstName + ' ' + this.lastName;
  },
  set: function (v) {
    if (v !== undefined) {
      var parts = v.split(' ');
      this.firstName = parts[0];
      this.lastName = parts[1];
    }
  }
});

var User = lounge.model('User', userSchema);
var user = new User({firstName: 'Bob', lastName: 'Smith'});
console.log(user.firstName); // Bob Smith
</code></pre>
<p>If no <code>set</code> function is defined the virtual is read-only.</p>
<p><strong>Statics</strong></p>
<p>Adding static methods to Models can be accomplished using <code>static()</code> schema function</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  firstName: String, 
  lastName: String
});

userSchema.static('foo', function(p, q) {
  return p + q;
});

var User = lounge.model('User', userSchema);
User.foo(1, 2); // 3
</code></pre>
<p>We can also pass an object of function keys and function values, and they will all be added.</p>
<p><strong>Methods</strong></p>
<p>Similarly adding instance methods to Models can be done using <code>method()</code> schema function.</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  firstName: String, 
  lastName: String
});

userSchema.method('fullName', function() {
  return this.firstName + ' ' + this.lastName;
});

var User = lounge.model('User', userSchema);
var user = new User({firstName: 'Bob', lastName: 'Smith'});
user.fullName(); // 'Bob Smith'
</code></pre>
<p>We can also pass an object of function keys and function values, and they will all be added.</p>
<p><strong>init() method</strong></p>
<p>There is a special <code>init</code> method that if specified in schema definition will be called at the end of model creation.
You can do additional setup here. This method is not passed in any arguments.</p>
<p><strong>toObject()</strong></p>
<p>Model instances come with <code>toObject</code> function that is automatically used for <code>console.log</code> inspection.</p>
<p>Options:</p>
<ul>
<li><code>transform</code> - function used to transform an object once it's been converted to plain javascript representation from a
model instance.</li>
<li><code>minimize</code> - to &quot;minimize&quot; the document by removing any empty properties. Default: <code>true</code></li>
<li><code>virtuals</code> - to apply virtual getters</li>
</ul>
<p>These settings can be applied on any invocation of <code>toObject</code> as well they can be set at schema level.</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  name: String,
  email: String,
  password: String
});

var xform = function (doc, ret, options) {
  delete ret.password;
  return ret;
};

userSchema.set('toObject', {transform: xform});

var User = lounge.model('User', userSchema);

var user = new User({
  name: 'Joe',
  email: 'joe@gmail.com',
  password: 'password'
});

console.log(user); // { name: 'Joe', email: 'joe@gmail.com' }
</code></pre>
<p><strong>toJSON()</strong></p>
<p>Similar to <code>toObject</code>. The return value of this method is used in calls to <code>JSON.stringify</code>.</p>
<p><strong>CAS</strong></p>
<p>All document instances have a read-only property <code>cas</code> that returns the string representation of the CAS object retrieved
from the database. The <code>cas</code> property is initialized only once a document has been retrieved from the database using one
of query functions, or once it has been saved. Alternatively we can use the method <code>getCAS(raw)</code> to get the cas value.
If <code>raw</code> is <code>true</code> then we return the raw CAS object. Otherwise we return string representation. This can be useful
for computation of ETag values for example.</p>
<pre><code class="language-js">console.log(doc.cas); // String: 00000000a71626e4
console.log(doc.getCAS()); // String: 00000000a71626e4
console.log(doc.getCAS(true)); // Object: CouchbaseCas&lt;11338961768815788032&gt;
</code></pre>
<p><strong>Useful member variables</strong></p>
<p>All model instances come with a <code>modelName</code> read only property that you can use to access the model name. As well
instances have <code>schema</code> property that represents the models schema used when creating the model with <code>model()</code> function.</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  name: String,
  email: String
});

var User = lounge.model('User', userSchema);
var user = new User({name: 'Bob Smith'});

console.log(user.modelName); // 'User'
console.log(user.schema instanceof lounge.Schema); // true
</code></pre>
<p>Since by default models are created using <code>strict</code> mode, Model instances setup and expose an internal <code>$_data</code> variable
that can be used for any internal storage that's not part of model definition as specified inside of schema.
This variable is not saved into the database. This can be used in combination with <code>init</code> function:</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  name: String,
  email: String
});

userSchema.method('init', function() {
  // store any logic stuff into $_data
  this.$_data.initialEmail = this.email;
  // later we can see if email was changed for example
});
</code></pre>
<h3>Middleware <a id="middleware"></a></h3>
<p>Similar to Mongoose middleware, Lounge exposes <code>pre</code> and <code>post</code> <a href="https://www.npmjs.com/package/hooks-fixed">hooks</a>.
Normally this is used to do additional validation pre save, and cleanup post document removal. Although the hooks can be
setup for any method including <code>toObject</code> and <code>toJON</code> methods.</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  firstName: String,
  lastName: String,
  email: String
});

userSchema.pre('save', function (next) {
  if (this.email) {
    this.email = this.email.toLowerCase();
  }

  // we must call next to continue control flow 
  next();
});

userSchema.post('remove', function () {
  console.log('document %s removed', this.id);
});
</code></pre>
<p>Important note here is that post 'save' and 'remove' hooks do not receive any form of control flow. There are no
callbacks passed.</p>
<p>The callback passed into pre hooks have be used to control flow of logic and execution:</p>
<pre><code class="language-js">schema.pre('save', function (next) {
  // some custom validation method
  if (!this.validate()) {
    return next(new Error('Validation error!'));
  }
 
  next();
});

// elsewhere...

doc.save(function(err, savedDoc) {
  if(err) console.log(err); // 'Validation error!' Document was not saved
});
</code></pre>
<h3>Schema Extension <a id="schema-extend"></a></h3>
<p>It is useful to have a common base schema, that all other schemas / models would extend or &quot;inherit&quot; properties from.
This can be accomplished by using the <code>Schema.extend</code> function. When used all properties, virtuals,
methods, statics, and middleware that are present in the base schema <strong>but not</strong> present in destination schema are copied
into the destination schema.</p>
<pre><code class="language-js"> var baseSchema = lounge.schema({
  metadata: {
    doc_type: String,
    createdAt: Date,
    updatedAt: Date
  }
});

baseSchema.pre('save', function (next) {
  if (!this.metadata) {
    this.metadata = {};
  }

  var now = new Date();

  if (!this.metadata.createdAt) {
    this.metadata.createdAt = now;
  }

  this.metadata.updatedAt = now;
  this.metadata.doc_type = this.modelName;

  next();
});

baseSchema.method('baseFoo', function () {
  console.log('base foo');
});

var userSchema = lounge.schema({
  name: String,
  email: String,
});

userSchema.pre('save', function (next) {
  if (this.email) {
    this.email = this.email.toLowerCase();
  }

  next();
});

userSchema.method('userFoo', function () {
  console.log('user foo');
});

// make user schema extend the base schema 
userSchema.extend(baseSchema);
var User = lounge.model('User', userSchema);

user = new User({
  name: 'Bob Smith',
  email: 'BSmith@gmail.com'
});

user.baseFoo() // prints 'base foo'
user.userFoo() // prints 'user foo'

user.save(function(err, savedDoc) {
  console.log(user.metadata.updatedAt); // Sat Dec 29 2015 03:30:00 GMT-0400 (AST)
  console.log(user.metadata.doc_type); // 'user'
  console.log(user.email); // 'bsmith@gmail.com'
});
</code></pre>
<h3>Embedded Documents <a id="embedded"></a></h3>
<p>Lounge allows for embedding and referencing other Models within schema.</p>
<pre><code class="language-js">var addressSchema = lounge.schema({
  street: String,
  city: String,
  country: String
});

var Address = lounge.model('Address', addressSchema);

var blogPostSchema = lounge.schema({
  title: String,
  body: String,
});

var BlogPost = lounge.model('BlogPost', blogPostSchema);

var userSchema = lounge.schema({
  name: String,
  address: Address,
  posts: [BlogPost]
});

var post = new BlogPost({
  title: 'Foo',
  body: 'Lorem ipsum'
});

var user = new User({
  name: 'Bob Smith',
  posts: [post],
  address: new Address({
    street: '123 Fake Street',
    city: 'Springfield',
    country: 'USA'
  })
});

user.posts.push(new BlogPost({
  title: 'Post 2',
  body: 'Some more text!'
});
</code></pre>
<p>You can manipulate and work with subdocument just like any model instances. When the top level document is saved
all child subdocuments are saved as well. Subdocuments <strong>must</strong> be an instance of the Model defined in the schema or a
<code>String</code> in which case it represents the key / id of the subdocument.</p>
<h3>Saving Documents <a id="saving"></a></h3>
<p>Saving documents is done using <code>save</code> function that every model instance has. This will execute all pre
'save' middleware and then perform Couchbase <code>upsert</code> operation on any subdocuments and the actual document. It will also
perform lookup document updates and finally execute any post hook middleware.</p>
<p>From our example code above:</p>
<pre><code class="language-js">user.save(function(err, savedDoc) {
  if(err) console.log(err);
});
</code></pre>
<p>All documents and subdocuments would be upserted into the database.</p>
<p><strong>Model.save(data, options, fn)</strong></p>
<p><code>data</code> - any data to be set into the model before saving.</p>
<p><strong>options</strong></p>
<p>All options not present here are first looked up from schema options, and then from config options.</p>
<ul>
<li><code>storeFullReferenceId</code> - whether to save embedded document property values as full document keys or just the base value</li>
<li><code>storeFullKey</code> - whether to save the internal document key property as fully expanded value or as the simple value</li>
<li><code>refIndexKeyPrefix</code> - lookup index document key prefix.</li>
<li><code>waitForIndex</code> - whether we want to wait for indexing to finish before returning. default is false.</li>
<li><code>virtuals</code> - whether we want to save virtuals. default is <code>false</code>.</li>
<li><code>minimize</code> - to &quot;minimize&quot; the document by removing any empty properties. Default: <code>true</code></li>
<li><code>expiry</code> - couchbase upsert option</li>
<li><code>persist_to</code> - couchbase persist_to option</li>
<li><code>replicate_to</code> - couchbase option</li>
</ul>
<h3>Getting Documents <a id="getting"></a></h3>
<p>All models created come with a static function <code>findById</code> that can be used to look up a single or multiple keys and
retrieve documents from the database. If key does not exist and document is not found we <strong>do not</strong> return an error
but also no model is generated. This is different than present couchbase module behaviour.</p>
<pre><code class="language-js">User.findById('user123', function(err, doc) {
  if(err) console.log(err); // there was an error looking up the key
  else if(!doc) console.log('no document found');
  else console.log(doc); // doc is instance of User and will print it out 
});
</code></pre>
<p>We can get multiple keys using an array as the first parameter. In this case, the callback invoked is passed 3 arguments
in form <code>(err, documents, misses)</code>.</p>
<pre><code class="language-js">User.findById(['user123', 'user456'], function(err, docs, misses) {
  if(err) console.log(err); // there was an error looking up the key
  console.dir(docs);        // array of Users found
  console.dir(misses);      // array if keys not found.
});
</code></pre>
<p>When <code>findById</code> is invoked using a single string argument the result returned is a single model instance. When an array
is passed in we return the results as described above. To force &quot;array&quot; type of returns in ALL cases, set the Lounge
config option <code>alwaysReturnArrays</code> to <code>true</code>. Default is <code>false</code>.</p>
<h3>Population <a id="population"></a></h3>
<p><code>findById</code> comes with an options parameter that can have one property <code>populate</code> that can be used to dictate
if and how we want to get any embedded subdocuments from the database. If <code>populate</code> option is <code>true</code> all embedded
subdocuments are retrieved from the database.</p>
<p>From our &quot;Embedded Documents&quot; example, if we were to retrieve the user document created:</p>
<pre><code class="language-js">User.findById(userId, {populate: true}, function(err, doc) {
  console.log(user instanceof User); // true
  console.log(user.address instanceof Address); // true
  console.log(user.posts[0] instanceof BlogPost); // true
  
  console.log(user); // full user document with retrieved address and posts subdocuments
});
</code></pre>
<p>We can specify a single field to populate:</p>
<pre><code class="language-js">User.findById(userId, {populate: 'address'}, function(err, doc) {
  console.log(user instanceof User); // true
  console.log(user.address instanceof Address); // true
  console.log(user.posts[0] instanceof BlogPost); // false 
  console.log(user.posts[0] instanceof String); // true - posts is an array of string keys
});
</code></pre>
<pre><code class="language-js">User.findById(userId, {populate: 'posts'}, function(err, doc) {
  console.log(user instanceof User); // true
  console.log(user.address instanceof Address); // false
  console.log(user.posts[0] instanceof BlogPost); // true
});
</code></pre>
<p>We can explicitly specify array indexes to populate</p>
<pre><code class="language-js">User.findById(userId, {populate: 'posts.1'}, function(err, doc) {
  console.log(user instanceof User); // true
  console.log(user.address instanceof Address); // false
  console.log(user.posts[0] instanceof BlogPost); // false
  console.log(user.posts[0] instanceof String); // true
  console.log(user.posts[1] instanceof BlogPost); // true - fully populated
});
</code></pre>
<p>Finally, <code>populate</code> can accept an array if fields to populate:</p>
<pre><code class="language-js">User.findById(userId, {populate: ['address', 'posts.1']}, function(err, doc) {
  console.log(user instanceof User); // true
  console.log(user.address instanceof Address); // true - fully populated
  console.log(user.posts[0] instanceof BlogPost); // false
  console.log(user.posts[0] instanceof String); // true
  console.log(user.posts[1] instanceof BlogPost); // true - fully populated
});
</code></pre>
<h3>Removing Documents <a id="removing"></a></h3>
<p>Removing documents is done using <code>remove</code> function that every model instance has. This will execute all pre
'remove' middleware and then perform Couchbase <code>remove</code> operation. It will also perform lookup document updates
and finally execute any post hook middleware. By default this function <strong>does not</strong> remove embedded documents. To do
this set <code>removeRefs</code> options to <code>true</code>.</p>
<pre><code class="language-js">user.remove(function(err, doc) {
  if(err) console.log(err);
});
</code></pre>
<p>If we want all subdocuments to be removed:</p>
<pre><code class="language-js">user.remove(function(err, {removeRefs: true}, doc) {
  if(err) console.log(err);
});
</code></pre>
<p>This will execute removal, hooks and indexing operations for all documents and subdocuments.</p>
<h3>Indexes <a id="indexes"></a></h3>
<p>Lounge provides Indexing mechanism using <a href="http://docs.couchbase.com/developer/dev-guide-3.0/lookups.html">reference lookup documents</a>.
This allows us to set up simple one to one lookups for easier document retrieval where we do not need to do create view
indexes. Specifying an index property is done at schema level:</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  name: String,
  email: {type: String, index: true}
});
</code></pre>
<p>Here we wish <code>User</code> models to have their own <code>id</code> as document key, but we want to be able to look up documents via email
as well as that is also unique property for users. Lounge will automatically manage (remove and upsert) lookup documents,
as user is <code>saved</code> or <code>removed</code>.</p>
<pre><code class="language-js">var user = new User({
  name: 'Joe Smith',
  email: 'joe@gmail.com'
});

user.save();
</code></pre>
<p>This will create the a lookup document similar to:</p>
<pre><code>{ key: '2ba8a471-063b-420a-aa83-31debe58f46f' }
</code></pre>
<p>with document key <code>'$_ref_by_email_joe@gmail.com'</code>. We can manipulate this behaviour using schema options.</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  name: String,
  email: {type: String, index: true}
}, {
  keyPrefix: 'user::',
  delimiter: '::'
});
</code></pre>
<p>Saving a document defined with this schema will save user document with key <code>'user::5c4bfd6d-9c80-452b-be3a-3e528e4f53f5'</code>
and will save a lookup document with key <code>''user::$_ref_by_email::joe@gmail.com'</code>. Setting <code>refIndexKeyPrefix</code> can add
additional customization.</p>
<pre><code class="language-js">{
  keyPrefix: 'user::',
  delimiter: '::',
  refIndexKeyPrefix: 'lookup_by_'
}
</code></pre>
<p>This will result in lookup document key <code>user::lookup_by_email::joe@gmail.com</code>.</p>
<p>Indexes can also be arrays:</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  name: String
  usernames: [{type: String, index: true}]
});
</code></pre>
<p>A lookup document will be generated for each value in the array. Index lookup properties have to be of type <code>String</code> or
<code>Number</code>.</p>
<p>Index lookup documents are automatically managed by lounge when documents are saved and removed using <code>save()</code> and
<code>remove()</code> functions. You can also manually kick of this process by calling <code>index()</code> function on any model instance.</p>
<h3>Index queries <a id="queries"></a></h3>
<p>Any indexed property the Model will automatically get a <code>findBy*</code> static function for easier lookup.
For example code above:</p>
<pre><code class="language-js">var User = lounge.model('User', userSchema);

User.findByEmail('joe@gmail.com', function(err, doc) {
  if(err) console.log(err);
  else console.log(doc);
});
</code></pre>
<p>We automatically singularize and camelize property key to derive the index name. So <code>usernames</code> becomes <code>findByUsername</code>.
We can specify the index &quot;name&quot; by passing along the <code>indexName</code> property. For example:</p>
<pre><code class="language-js">var userSchema = lounge.schema({
  name: String
  usernames: [{type: String, index: true, indexName: 'UN'}]
});

var User = lounge.model('User', userSchema);

User.findByUN('user1', function(err, doc) {
  if(err) console.log(err);
  else console.log(doc);
});
</code></pre>
<h3>Events <a id="events"></a></h3>
<p>All model instances inherit <a href="https://nodejs.org/api/events.html#events_class_events_eventemitter"><code>EventEmitter</code></a>, and
emit three events:</p>
<ul>
<li><code>index</code> - when indexing of lookup documents finished regardless if successful or not. Emits <code>error</code> if there was any.</li>
<li><code>save</code> - when the document was successfully saved.</li>
<li><code>remove</code> - when the document was successfully removed.</li>
</ul>
<pre><code class="language-js">var userSchema = lounge.schema({
  name: String,
  email: {type: String, index: true}
});

var User = lounge.model('User', userSchema);
var user = new User({
  name: 'Bob Smith',
  email: 'bob@gmail.com'
});

user.on('index', function (err) {
  if(err) console.log('Error indexing document' + err.message);
});

user.on('remove', function (doc) {
  console.log('document removed');
});

user.on('save', function (doc) {
  console.log('document saved');
});
</code></pre>
<h3>API Documentation <a id="apidocs"></a></h3>
<p><a href="http://bojand.github.io/lounge/api">API Documentation</a></p>
<h2>TESTS</h2>
<p>Module automated tests can be run using <code>npm test</code> command. The tests are executed using <a href="https://github.com/couchbase/couchnode#mock-testing">Couchbase mocking</a>.
To run tests against an actual local database create a bucket <code>lounge_test</code> and remove <code>LOUNGE_COUCHBASE_MOCK=true</code> from
<code>test</code> script property in <code>package.json</code>.</p>
<h2>TODO</h2>
<p>See <a href="https://github.com/bojand/lounge/blob/master/TODO.md">TODO.md</a>.</p>
<h2>Credits</h2>
<p>Lots of code and design inspired by <a href="http://mongoosejs.com/">Mongoose</a>.
Uses modified version of <a href="https://github.com/jwerle/draft">Draft</a> for schema and modelling.</p>
<h2>License</h2>
<p>Copyright 2015 Bojan Djurkovic</p>
<p>Licensed under the MIT License.</p>
</section>
          <div class="footer site-footer">
            <div class="span site-footer-owner"><a href="https://github.com/mr-doc/mr-doc-theme-cayman">Cayman</a> is maintained by <a href="https://github.com/iwatakeshi">iwatakeshi</a>.</div>
            <div class="span site-footer-credits">This page was generated by <a href="https://github.com/mr-doc/mr-doc">Mr. Doc</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</div>
          </div>
        </div>
      </div>
    </section>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/affix.js"></script>
    <script src="js/dropdown.js"></script>
    <script src="js/scrollspy.js"></script>
    <script src="js/prism.js"></script>
    <script src="js/prism-bash.js"></script>
    <script>
      $(document).ready(function(){
        $('body').scrollspy({
          target: ".bs-docs-sidebar",
          offset: 40
        });
        $('#sidebar').affix({
          offset:{
            bottom:60,
            top: 60
          }
        }) 
      });
    </script>
  </body>
</html>