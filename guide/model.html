<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <title>Lounge</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" type="text/css">
    <link rel="stylesheet" href="../api/css/bootstrap.css">
    <link rel="stylesheet" href="../api/css/cayman.css">
    <link rel="stylesheet" href="../api/css/prism.css">
</head>
<body>
<section class="page-header">
    <h1 class="project-name">Lounge</h1>

    <h2 class="project-tagline">Simple Mongoose-inspired ODM for Couchbase</h2>
    <a href="http://bojand.github.io/lounge" class="btn">Home</a>
    <a href="https://github.com/bojand/lounge" target="_blank" class="btn">View on GitHub</a>
    <a href="https://npmjs.com/package/lounge" target="_blank" class="btn">View on npm</a>
</section>
<section data-spy="scroll" data-target=".scrollspy" class="main-content">
    <div class="row">
        <div class="col-md-3 col-xs-3 bs-docs-sidebar">
            <ul id="sidebar" class="nav nav-stacked fixed">
                <li><a href="index.html">Setup</a></li>
                <li><a href="model.html">Modelling</a></li>
                <li><a href="mw.html">Middleware</a></li>
                <li><a href="extend.html">Schema Extension</a></li>
                <li><a href="embedded.html">Embedded</a></li>
                <li><a href="saving.html">Saving Documents</a></li>
                <li><a href="getting.html">Retrieving Documents</a></li>
                <li><a href="removing.html">Removing Documents</a></li>
                <li><a href="populate.html">Population</a></li>
                <li><a href="indexes.html">Indexes</a></li>
                <li><a href="events.html">Events</a></li>
            </ul>
        </div>
        <div class="col-md-9">
            <section id="Main" class="readme">
<h3 id="modelling-a-id-model-a-">Modelling <a id="model"></a></h3>
<p><strong>Basics</strong></p>
<p>We begin defining a data model using a schema.</p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  firstName: String,
  lastName: String,
  age: Number,
  usernames: [String],
  setup: Boolean
  metadata: {
    createdAt: Date,
    updatedAt: Date
  }
});
</code></pre>
<p>We can add additional properties using <code>add</code> function:</p>
<pre><code class="lang-js">userSchema.add(&#39;name&#39;, String);
</code></pre>
<p>Alternatively we can explicitly specify the type using <code>type</code> property:</p>
<pre><code class="lang-js">var catSchema = lounge.schema({
  name: { type: String }
  breed: String,
});

catSchema.add(&#39;age&#39;, {type: String});
</code></pre>
<p>Schema options can be set at construction or using the <code>set</code> function.</p>
<pre><code class="lang-js">var catSchema = lounge.schema({
  name: { type: String }
  breed: String,
}, {
  keyPrefix: &#39;cat::&#39;
});

catSchema.set(&#39;refIndexKeyPrefix&#39;, &#39;::&#39;);
</code></pre>
<p><strong>Document keys</strong></p>
<p>By default schemas come with an <code>id</code> property as the document key, and the automatically generated value will be
a <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a> 
using <a href="https://www.npmjs.com/package/node-uuid">node-uuid</a> <code>v4()</code> function. This should be most practical and 
appropriate in a lot of cases. Alternatively you can specify explicit key properties:</p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  firstName: String,
  lastName: String,
  email: { type: String, key: true, generate: false }
});
</code></pre>
<p>Here we desire <code>email</code> to be used as the document key and we specify <code>generate: false</code> because we do not want Lounge
to automatically handle key property value generation. If we still want uuid generation but in a different property 
we can specify so:</p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  firstName: String,
  lastName: String,
  email: String,
  userId: {type: String, key: true, generate: true }
});
</code></pre>
<p><code>generate</code> does not have to be set explicitly to <code>true</code> as that is the default.</p>
<p>We can specify additional prefix and/or suffix for keys. This will be used when wrigin to the database as the actual
document key.</p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  firstName: String,
  lastName: String,
  email: { type: String, key: true, generate: false, prefix: &#39;user&#39;}
});
</code></pre>
<p>Note that setting prefix and suffix options like this will take presidence over any <code>keyPrefix</code> and <code>keySuffix</code> 
options specified in the second options parameter to the <code>schema()</code> call or any settings in the lounge config.</p>
<p><strong>Examples</strong></p>
<pre><code class="lang-js">var lounge = require(&#39;lounge&#39;);

// ... connect

var userSchema = lounge.schema({
  name: String
  email: { type: String, key: true, generate: false, prefix: &#39;user::&#39;}
});

var User = lounge.model(&#39;User&#39;, userSchema);
var user = new User({name: &#39;Bob Smith&#39;, email: &#39;bsmith@acme.com&#39;});
user.save();
</code></pre>
<p>This will save the user document under key <code>user::bsmith@acme.com</code>.</p>
<pre><code class="lang-js">var lounge = require(&#39;lounge&#39;);

// ... connect

var userSchema = lounge.schema({
  name: String
}, {
  keyPrefix: &#39;user::&#39;
});

var User = lounge.model(&#39;User&#39;, userSchema);
var user = new User({name: &#39;Bob Smith&#39;});
user.save();
</code></pre>
<p>This will automatically generate a uuid <code>id</code> property and save the user document under key 
similar to <code>user::110ec58a-a0f2-4ac4-8393-c866d813b8d1</code>.</p>
<p><strong>Data manipulation</strong></p>
<p>Data in Model instances can be access directly or using <code>get</code> function. Similarly it can be manipulated using 
either assignment operator or using the <code>set</code> function. In either case the input value is validated to be of proper type.</p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  name: String
  friends: Number,
  dob: Date,
  setup: Boolean
});

var User = lounge.model(&#39;User&#39;, userSchema);
var user = new User({name: &#39;Bob Smith&#39;});

user.get(&#39;name&#39;); // &#39;Bob Smith&#39;
user.name = &#39;Joe&#39;; // OK
user.name.set(&#39;Joe&#39;); // OK
console.log(user.name); // &#39;Joe&#39;
user.set(&#39;friends&#39;, 20); // OK
user.friends = &#39;abc&#39;; // nope. still 20
user.dob = new Date(&#39;July 5, 1980&#39;);
user.get(&#39;dob&#39;); // instance of Date
user.set(&#39;setup&#39;, &#39;yup&#39;); // nope
user.setup = true; // OK
</code></pre>
<p><strong>Validation</strong></p>
<p>Lounge does automatic validation against input data using the type information specified in the schema definition.
We can provide custom validation in schema definition by providing <code>validator</code> function.</p>
<pre><code class="lang-js">var validator = require(&#39;validator&#39;); // Node validator module

var userSchema = lounge.schema({
  name: String
  email: {type: String, validator: validator.isEmail}
});

var User = lounge.model(&#39;User&#39;, userSchema);
var user = new User({ name: &#39;Bob Smith&#39; });

user.email = &#39;bob@gmail.com&#39;; // OK
user.email = &#39;bsmith&#39;; // Nope
console.log(user.email); // &#39;bob@gmail.com&#39;
</code></pre>
<p><strong>Virtuals</strong></p>
<p>Virtuals are document properties that you can get and set but that do not get persisted to the database. 
The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value 
into multiple values for storage.</p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  firstName: String, 
  lastName: String
});

userSchema.virtual(&#39;fullName&#39;, {
  get: function () {
    return this.firstName + &#39; &#39; + this.lastName;
  },
  set: function (v) {
    if (v !== undefined) {
      var parts = v.split(&#39; &#39;);
      this.firstName = parts[0];
      this.lastName = parts[1];
    }
  }
});

var User = lounge.model(&#39;User&#39;, userSchema);
var user = new User({firstName: &#39;Bob&#39;, lastName: &#39;Smith&#39;});
console.log(user.firstName); // Bob Smith
</code></pre>
<p>If no <code>set</code> function is defined the virtual is read-only.</p>
<p><strong>Statics</strong></p>
<p>Adding static methods to Models can be accomplished using <code>static()</code> schema function</p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  firstName: String, 
  lastName: String
});

userSchema.static(&#39;foo&#39;, function(p, q) {
  return p + q;
});

var User = lounge.model(&#39;User&#39;, userSchema);
User.foo(1, 2); // 3
</code></pre>
<p>We can also pass an object of function keys and function values, and they will all be added.</p>
<p><strong>Methods</strong></p>
<p>Similarly adding instance methods to Models can be done using <code>method()</code> schema function. </p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  firstName: String, 
  lastName: String
});

userSchema.method(&#39;fullName&#39;, function() {
  return this.firstName + &#39; &#39; + this.lastName;
});

var User = lounge.model(&#39;User&#39;, userSchema);
var user = new User({firstName: &#39;Bob&#39;, lastName: &#39;Smith&#39;});
user.fullName(); // &#39;Bob Smith&#39;
</code></pre>
<p>We can also pass an object of function keys and function values, and they will all be added.</p>
<p><strong>init() method</strong></p>
<p>There is a special <code>init</code> method that if specified in schema definition will be called at the end of model creation. 
You can do additional setup here. This method is not passed in any arguments.</p>
<p><strong>toObject()</strong></p>
<p>Model instances come with <code>toObject</code> function that is automatically used for <code>console.log</code> inspection. </p>
<p>Options:</p>
<ul>
<li><code>transform</code> - function used to transform an object once it&#39;s been converted to plain javascript representation from a
model instance.</li>
<li><code>minimize</code> - to &quot;minimize&quot; the document by removing any empty properties. Default: <code>true</code></li>
<li><code>virtuals</code> - to apply virtual getters</li>
</ul>
<p>These settings can be applied on any invocation of <code>toObject</code> as well they can be set at schema level.</p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  name: String,
  email: String,
  password: String
});

var xform = function (doc, ret, options) {
  delete ret.password;
  return ret;
};

userSchema.set(&#39;toObject&#39;, {transform: xform});

var User = lounge.model(&#39;User&#39;, userSchema);

var user = new User({
  name: &#39;Joe&#39;,
  email: &#39;joe@gmail.com&#39;,
  password: &#39;password&#39;
});

console.log(user); // { name: &#39;Joe&#39;, email: &#39;joe@gmail.com&#39; }
</code></pre>
<p><strong>toJSON()</strong></p>
<p>Similar to <code>toObject</code>. The return value of this method is used in calls to <code>JSON.stringify</code>.</p>
<p><strong>CAS</strong></p>
<p>All document instances have a read-only property <code>cas</code> that returns the string representation of the CAS object retrieved
from the database. The <code>cas</code> property is initialized only once a document has been retrieved from the database using one
of query functions, or once it has been saved. Alternatively we can use the method <code>getCAS(raw)</code> to get the cas value.
If <code>raw</code> is <code>true</code> then we return the raw CAS object. Otherwise we return string representation. This can be useful
for computation of ETag values for example.</p>
<pre><code class="lang-js">console.log(doc.cas); // String: 00000000a71626e4
console.log(doc.getCAS()); // String: 00000000a71626e4
console.log(doc.getCAS(true)); // Object: CouchbaseCas&lt;11338961768815788032&gt;
</code></pre>
<p><strong>Useful member variables</strong></p>
<p>All model instances come with a <code>modelName</code> read only property that you can use to access the model name. As well
instances have <code>schema</code> property that represents the models schema used when creating the model with <code>model()</code> function.</p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  name: String,
  email: String
});

var User = lounge.model(&#39;User&#39;, userSchema);
var user = new User({name: &#39;Bob Smith&#39;});

console.log(user.modelName); // &#39;User&#39;
console.log(user.schema instanceof lounge.Schema); // true
</code></pre>
<p>Since by default models are created using <code>strict</code> mode, Model instances setup and expose an internal <code>$_data</code> variable 
that can be used for any internal storage that&#39;s not part of model definition as specified inside of schema. 
This variable is not saved into the database. This can be used in combination with <code>init</code> function:</p>
<pre><code class="lang-js">var userSchema = lounge.schema({
  name: String,
  email: String
});

userSchema.method(&#39;init&#39;, function() {
  // store any logic stuff into $_data
  this.$_data.initialEmail = this.email;
  // later we can see if email was changed for example
});
</code></pre>
</section>
</div>
</div>
</section>
<script src="../api/js/jquery.min.js"></script>
<script src="../api/js/bootstrap.min.js"></script>
<script src="../api/js/affix.js"></script>
<script src="../api/js/dropdown.js"></script>
<script src="../api/js/scrollspy.js"></script>
<script src="../api/js/prism.js"></script>
<script src="../api/js/prism-bash.js"></script>
<script>
    $(document).ready(function () {
        $('body').scrollspy({
            target: ".bs-docs-sidebar",
            offset: 40
        });
        $('#sidebar').affix({
            offset: {
                bottom: 60,
                top: 60
            }
        })
    });
</script>
</body>
</html>