{"name":"Lounge","tagline":"Simple Mongoose-inspired ODM for Couchbase.","body":"# Lounge\r\n\r\nSimple Mongoose-inspired ODM for [Couchbase](http://www.couchbase.com).\r\n\r\n## Installation\r\n\r\n`npm install lounge`\r\n\r\n## Stability\r\n\r\nThis module is under development and there could be bugs. API may not be 100% locked down. \r\nDocumentation is still work in progress.\r\n\r\n## Overview\r\n\r\nLounge is a simple, somewhat opinionated, Mongoose-inspired ODM for [Couchbase](http://www.couchbase.com). Main goal is\r\nto provide modeling tool framework for working with Couchbase databases in an asynchronous environment of Node.js. \r\n\r\n```js\r\nvar lounge = require('lounge');\r\nlounge.connect('couchbase://127.0.0.1');\r\n\r\nvar schema = lounge.schema({ name: String });\r\nvar Cat = lounge.model('Cat', schema);\r\n\r\nvar kitty = new Cat({ name: 'Zildjian' });\r\nkitty.save(function (err) {\r\n  if (err) // ...\r\n  console.log('meow');\r\n});\r\n```\r\n\r\n##### Features:\r\n\r\n* Schema definition\r\n* Strict modelling based on schema\r\n* Schema extension\r\n* Automatic type validation and custom validation\r\n* Document upsert and removal\r\n* Embedded (referenced) documents\r\n* Automatic and manual population of embedded (referenced) document\r\n* Middleware including pre and post hooks\r\n* Indexing using [reference lookup documents](http://docs.couchbase.com/developer/dev-guide-3.0/lookups.html)\r\n\r\n##### Outside of the scope of this module:\r\n\r\n* Document and view management. There are too many patterns and ways of performing document and view management and \r\n view lookup that it is impractical to accommodate anything sane within a simple ODM. This can easily be expanded\r\n on top of Lounge.\r\n* View queries. For same reasons this falls outside of the scope of Lounge.\r\n* Automatic document removal on key change. That is if a document key property changes, the new document is saved under\r\nthe new key. The old document sticks around under the old key. There are too many implications if we start automatically\r\nhandle document removal in this scenario. This should be handled by the user of this module.\r\n\r\n## Documentation\r\n\r\n* [Setup](#lounge)\r\n* [Modelling](#model)\r\n* [Middleware](#middleware)\r\n* [Schema Extension](#schema-extend)\r\n* [Embedded Documents](#embedded)\r\n* [Saving Documents](#saving)\r\n* [Removing Documents](#removing)\r\n* [Population](#population)\r\n* [Indexes](#indexes)\r\n* [Queries](#queries)\r\n* [Events](#events)\r\n\r\n### Setup <a id=\"lounge\"></a>\r\n\r\n```js\r\nvar lounge = require('lounge');\r\n```\r\n\r\nModule exports an instance of `Lounge` class.\r\n\r\n#### Lounge(options)\r\n\r\nCreates a new instance of `Lounge` class. You rarely have to do this.\r\n\r\n```js\r\nvar lounge = require('lounge');\r\nvar l = new lounge.Lounge();\r\n```\r\n\r\n**Options**\r\n\r\n* `keyPrefix` - key prefix for all keys. No default. Generally useful if you wish to namespace documents. \r\nExample: `app::env::`.\r\n* `storeFullReferenceId` - whether to store embedded document keys as fully expanded keys \r\n(with prefix and suffix applied) or just the minimized version. default: `false`. \r\n* `storeFullKey` - Similarly, to store the fully expanded document key inside the key property. default: `false`\r\n* `alwaysReturnArrays` - set to true to force `findyById` to always return an array of documents even if only\r\na single key is passed in. Default: `false`\r\n* `refIndexKeyPrefix` - reference lookup index document key prefix. The name of the index is appended to this.\r\nDefault: `'$_ref_by_'`\r\n* `delimiter` - delimiter string used for concatenation in reference document key expansion / generation. default: `'_'` \r\nThis is prepended to the reference document key.\r\n* `waitForIndex` - When documents are saved, indexes are updated. We can wait for this operation to finish before \r\nreturning from `save()`. Default: `false`\r\n* `minimize` - \"minimize\" schemas by removing empty objects. Default: `true`\r\n\r\nAny of these options, or additional variables can be manipulated using the `setOption` and `getOption` methods.\r\n  \r\n```js\r\nvar lounge = require('lounge');\r\nlounge.setOption('alwaysReturnArrays', true);\r\nconsole.log(lounge.getOption('alwaysReturnArrays');\r\n```\r\n\r\n#### Lounge.connect(options, fn, mock)\r\n\r\nConnects to the database cluster based on `options`. When completed calls `fn` callback. Set `mock` to `true` to use\r\n[Couchbase mocking](https://github.com/couchbase/couchnode#mock-testing). Alternatively you can set\r\n`LOUNGE_COUCHBASE_MOCK` environment variable. Returns an instance of Couchbase `bucket`.\r\n\r\n**Options**\r\n\r\n* `connectionString` - connection string for the cluster. See [Cluster documentation](http://docs.couchbase.com/sdk-api/couchbase-node-client-2.1.2/Cluster.html).\r\n* `bucket` - name of the bucket to be used for [`openBucket`](http://docs.couchbase.com/sdk-api/couchbase-node-client-2.1.2/Cluster.html#openBucket)\r\nor the actual, already connected, Couchbase `bucket` instance.\r\n* `password` - password for [`openBucket`](http://docs.couchbase.com/sdk-api/couchbase-node-client-2.1.2/Cluster.html#openBucket)\r\n* `certpath` - certpath for [cluster constructor](http://docs.couchbase.com/sdk-api/couchbase-node-client-2.1.2/Cluster.html).\r\n\r\n```js\r\nvar lounge = require('lounge');\r\nvar bucket = lounge.connect('couchbase://127.0.0.1', function(err, bucket) {\r\n  // ... connected\r\n});\r\n```\r\n\r\n#### Lounge.disconnect()\r\n\r\nDisconnect from the bucket. Deletes all defined models.\r\n\r\n#### Lounge.schema(descriptor, options)\r\n\r\nCreates a new `Schema` based on `descriptor` and `options`. Prefer this over the actual `Schema` constructor as this\r\nwill pass lounge config variables to the `Schema` constructor automatically. \r\n\r\nSchema construction options:\r\n\r\n* `keyPrefix` - key prefix for all keys. No default. Generally useful if you wish to namespace documents. Example: `app::env::`.\r\n* `keySuffix` - Similar as prefix but used as a suffix\r\n* `refIndexKeyPrefix` - reference lookup index document key prefix. The name of the index is appended. Default: '$_ref_by_'\r\nReference / lookup document keys are also treated using `keyPrefix` and `keySuffix` settings.  \r\n* `delimiter` - delimiter string used for concatenation in reference document key expansion / generation.\r\nDefault: '_'. This is prepended to the reference document key.\r\n* `minimize` - \"minimize\" schemas by removing empty objects. Default: `true`\r\n* `toObject` - toObject method options: `transform`, `virtuals` and `minimize`\r\n* `toJSON` - toJSON method options, similar to above\r\n* `strict` - ensures that value passed in ot assigned that were not specified in our schema do not get saved. Default: `true`\r\n\r\n#### Lounge.model(name, schema, options)\r\n\r\nDefines a Model based on case sensitive model `name` and created `schema`, with given options. From there we can create\r\ninstances of the Model;\r\n\r\n**Options**\r\n\r\n* `freeze` - to freeze the model. See `Object.freeze`. Default: `true`\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  firstName: String,\r\n  lastName: String,\r\n  email: String,\r\n  dateOfBirth: Date,\r\n});\r\n\r\nUser = lounge.model('User', userSchema);\r\nvar user = new User({\r\n  firstName: 'Joe',\r\n  lastName: 'Smith',\r\n  email: 'joe@gmail.com',\r\n  dateOfBirth: new Date()\r\n});\r\n\r\nconsole.log(user instanceof User) // true\r\n```\r\n\r\n#### Lounge.modelNames()\r\n\r\nReturns and array of all defined model names.\r\n\r\n#### Bucket functions\r\n\r\nLounge instance also inherits all public [`Bucket`](http://docs.couchbase.com/sdk-api/couchbase-node-client-2.1.2/Bucket.html)\r\n functions and properties.\r\n \r\n```js\r\nlounge.get('mydocumentkey', function(err, res) {\r\n  // .. save as if we did normal bucket.get()\r\n});\r\n```\r\n\r\n#### Lounge.Schema\r\n\r\nExported `Schema` constructor. You can use this as well as `lounge.schema()`, which is preferred.\r\n\r\n```js\r\nvar userSchema = new lounge.Schema({ name: String });\r\n```\r\n\r\n#### Lounge.Model\r\n\r\nExported `Model` constructor. You should never have to manually create a Model.\r\n\r\n#### Lounge.Document\r\n\r\nExported  internal `Document` constructor. You should never have to manually create a Document.\r\n \r\n```js\r\n// already defined User model\r\nvar user = new User({name: 'Bob'});\r\nconsole.log(user instanceof User) // true\r\nconsole.log(user instanceof lounge.Model) // true\r\nconsole.log(user instanceof lounge.Document) // true\r\n```\r\n\r\n### Modelling <a id=\"model\"></a>\r\n\r\n**Basics**\r\n\r\nWe begin defining a data model using a schema.\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  firstName: String,\r\n  lastName: String,\r\n  age: Number,\r\n  usernames: [String],\r\n  setup: Boolean\r\n  metadata: {\r\n    createdAt: Date,\r\n    updatedAt: Date\r\n  }\r\n});\r\n```\r\n\r\nWe can add additional properties using `add` function:\r\n\r\n```js\r\nuserSchema.add('name', String);\r\n```\r\n\r\nAlternatively we can explicitly specify the type using `type` property:\r\n\r\n```js\r\nvar catSchema = lounge.schema({\r\n  name: { type: String }\r\n  breed: String,\r\n});\r\n\r\ncatSchema.add('age', {type: String});\r\n```\r\n\r\nSchema options can be set at construction or using the `set` function.\r\n \r\n```js\r\nvar catSchema = lounge.schema({\r\n  name: { type: String }\r\n  breed: String,\r\n}, {\r\n  keyPrefix: 'cat::'\r\n});\r\n\r\ncatSchema.set('refIndexKeyPrefix', '::');\r\n```\r\n\r\n**Document keys**\r\n\r\nBy default schemas come with an `id` property as the document key, and the automatically generated value will be\r\na [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) \r\nusing [node-uuid](https://www.npmjs.com/package/node-uuid) `v4()` function. This should be most practical and \r\nappropriate in a lot of cases. Alternatively you can specify explicit key properties:\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  firstName: String,\r\n  lastName: String,\r\n  email: { type: String, key: true, generate: false }\r\n});\r\n```\r\n\r\nHere we desire `email` to be used as the document key and we specify `generate: false` because we do not want Lounge\r\nto automatically handle key property value generation. If we still want uuid generation but in a different property \r\nwe can specify so:\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  firstName: String,\r\n  lastName: String,\r\n  email: String,\r\n  userId: {type: String, key: true, generate: true }\r\n});\r\n```\r\n\r\n`generate` does not have to be set explicitly to `true` as that is the default.\r\n \r\nWe can specify additional prefix and/or suffix for keys. This will be used when wrigin to the database as the actual\r\ndocument key.\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  firstName: String,\r\n  lastName: String,\r\n  email: { type: String, key: true, generate: false, prefix: 'user'}\r\n});\r\n```\r\n\r\nNote that setting prefix and suffix options like this will take presidence over any `keyPrefix` and `keySuffix` \r\noptions specified in the second options parameter to the `schema()` call or any settings in the lounge config.\r\n\r\n**Examples**\r\n\r\n```js\r\nvar lounge = require('lounge');\r\n\r\n// ... connect\r\n\r\nvar userSchema = lounge.schema({\r\n  name: String\r\n  email: { type: String, key: true, generate: false, prefix: 'user::'}\r\n});\r\n\r\nvar User = lounge.model('User', userSchema);\r\nvar user = new User({name: 'Bob Smith', email: 'bsmith@acme.com'});\r\nuser.save();\r\n```\r\n\r\nThis will save the user document under key `user::bsmith@acme.com`.\r\n\r\n```js\r\nvar lounge = require('lounge');\r\n\r\n// ... connect\r\n\r\nvar userSchema = lounge.schema({\r\n  name: String\r\n}, {\r\n  keyPrefix: 'user::'\r\n});\r\n\r\nvar User = lounge.model('User', userSchema);\r\nvar user = new User({name: 'Bob Smith'});\r\nuser.save();\r\n```\r\n\r\nThis will automatically generate a uuid `id` property and save the user document under key \r\nsimilar to `user::110ec58a-a0f2-4ac4-8393-c866d813b8d1`.\r\n\r\n**Data manipulation**\r\n\r\nData in Model instances can be access directly or using `get` function. Similarly it can be manipulated using \r\neither assignment operator or using the `set` function. In either case the input value is validated to be of proper type.\r\n \r\n```js\r\nvar userSchema = lounge.schema({\r\n  name: String\r\n  friends: Number,\r\n  dob: Date,\r\n  setup: Boolean\r\n});\r\n\r\nvar User = lounge.model('User', userSchema);\r\nvar user = new User({name: 'Bob Smith'});\r\n\r\nuser.get('name'); // 'Bob Smith'\r\nuser.name = 'Joe'; // OK\r\nuser.name.set('Joe'); // OK\r\nconsole.log(user.name); // 'Joe'\r\nuser.set('friends', 20); // OK\r\nuser.friends = 'abc'; // nope. still 20\r\nuser.dob = new Date('July 5, 1980');\r\nuser.get('dob'); // instance of Date\r\nuser.set('setup', 'yup'); // nope\r\nuser.setup = true; // OK\r\n```\r\n\r\n**Validation**\r\n\r\nLounge does automatic validation against input data using the type information specified in the schema definition.\r\nWe can provide custom validation in schema definition by providing `validator` function.\r\n \r\n```js\r\nvar validator = require('validator'); // Node validator module\r\n\r\nvar userSchema = lounge.schema({\r\n  name: String\r\n  email: {type: String, validator: validator.isEmail}\r\n});\r\n\r\nvar User = lounge.model('User', userSchema);\r\nvar user = new User({ name: 'Bob Smith' });\r\n\r\nuser.email = 'bob@gmail.com'; // OK\r\nuser.email = 'bsmith'; // Nope\r\nconsole.log(user.email); // 'bob@gmail.com'\r\n```\r\n\r\n**Virtuals**\r\n\r\nVirtuals are document properties that you can get and set but that do not get persisted to the database. \r\nThe getters are useful for formatting or combining fields, while setters are useful for de-composing a single value \r\ninto multiple values for storage.\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  firstName: String, \r\n  lastName: String\r\n});\r\n\r\nuserSchema.virtual('fullName', {\r\n  get: function () {\r\n    return this.firstName + ' ' + this.lastName;\r\n  },\r\n  set: function (v) {\r\n    if (v !== undefined) {\r\n      var parts = v.split(' ');\r\n      this.firstName = parts[0];\r\n      this.lastName = parts[1];\r\n    }\r\n  }\r\n});\r\n\r\nvar User = lounge.model('User', userSchema);\r\nvar user = new User({firstName: 'Bob', lastName: 'Smith'});\r\nconsole.log(user.firstName); // Bob Smith\r\n```\r\n\r\nIf no `set` function is defined the virtual is read-only.\r\n\r\n**Statics**\r\n\r\nAdding static methods to Models can be accomplished using `static()` schema function\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  firstName: String, \r\n  lastName: String\r\n});\r\n\r\nuserSchema.static('foo', function(p, q) {\r\n  return p + q;\r\n});\r\n\r\nvar User = lounge.model('User', userSchema);\r\nUser.foo(1, 2); // 3\r\n```\r\n\r\nWe can also pass an object of function keys and function values, and they will all be added.\r\n\r\n**Methods**\r\n\r\nSimilarly adding instance methods to Models can be done using `method()` schema function. \r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  firstName: String, \r\n  lastName: String\r\n});\r\n\r\nuserSchema.method('fullName', function() {\r\n  return this.firstName + ' ' + this.lastName;\r\n});\r\n\r\nvar User = lounge.model('User', userSchema);\r\nvar user = new User({firstName: 'Bob', lastName: 'Smith'});\r\nuser.fullName(); // 'Bob Smith'\r\n```\r\n\r\nWe can also pass an object of function keys and function values, and they will all be added.\r\n\r\n**init() method**\r\n\r\nThere is a special `init` method that if specified in schema definition will be called at the end of model creation. \r\nYou can do additional setup here. This method is not passed in any arguments.\r\n\r\n**toObject()**\r\n\r\nModel instances come with `toObject` function that is automatically used for `console.log` inspection. \r\n\r\nOptions:\r\n\r\n* `transform` - function used to transform an object once it's been converted to plain javascript representation from a\r\nmodel instance.\r\n* `minimize` - to \"minimize\" the document by removing any empty properties. Default: `true`\r\n* `virtuals` - to apply virtual getters\r\n\r\nThese settings can be applied on any invocation of `toObject` as well they can be set at schema level.\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  name: String,\r\n  email: String,\r\n  password: String\r\n});\r\n\r\nvar xform = function (doc, ret, options) {\r\n  delete ret.password;\r\n  return ret;\r\n};\r\n\r\nuserSchema.set('toObject', {transform: xform});\r\n\r\nvar User = lounge.model('User', userSchema);\r\n\r\nvar user = new User({\r\n  name: 'Joe',\r\n  email: 'joe@gmail.com',\r\n  password: 'password'\r\n});\r\n\r\nconsole.log(user); // { name: 'Joe', email: 'joe@gmail.com' }\r\n```\r\n\r\n**toJSON()**\r\n\r\nSimilar to `toObject`. The return value of this method is used in calls to `JSON.stringify`.\r\n\r\n**CAS**\r\n\r\nAll document instances have a read-only property `cas` that returns the string representation of the CAS object retrieved\r\nfrom the database. The `cas` property is initialized only once a document has been retrieved from the database using one\r\nof query functions, or once it has been saved. Alternatively we can use the method `getCAS(raw)` to get the cas value.\r\nIf `raw` is `true` then we return the raw CAS object. Otherwise we return string representation. This can be useful\r\nfor computation of ETag values for example.\r\n\r\n```js\r\nconsole.log(doc.cas); // String: 00000000a71626e4\r\nconsole.log(doc.getCAS()); // String: 00000000a71626e4\r\nconsole.log(doc.getCAS(true)); // Object: CouchbaseCas<11338961768815788032>\r\n```\r\n\r\n**Useful member variables**\r\n\r\nAll model instances come with a `modelName` read only property that you can use to access the model name. As well\r\ninstances have `schema` property that represents the models schema used when creating the model with `model()` function.\r\n \r\n```js\r\nvar userSchema = lounge.schema({\r\n  name: String,\r\n  email: String\r\n});\r\n\r\nvar User = lounge.model('User', userSchema);\r\nvar user = new User({name: 'Bob Smith'});\r\n\r\nconsole.log(user.modelName); // 'User'\r\nconsole.log(user.schema instanceof lounge.Schema); // true\r\n```\r\n\r\nSince by default models are created using `strict` mode, Model instances setup and expose an internal `$_data` variable \r\nthat can be used for any internal storage that's not part of model definition as specified inside of schema. \r\nThis variable is not saved into the database. This can be used in combination with `init` function:\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  name: String,\r\n  email: String\r\n});\r\n\r\nuserSchema.method('init', function() {\r\n  // store any logic stuff into $_data\r\n  this.$_data.initialEmail = this.email;\r\n  // later we can see if email was changed for example\r\n});\r\n```\r\n\r\n### Middleware <a id=\"middleware\"></a>\r\n\r\nSimilar to Mongoose middleware, Lounge exposes `pre` and `post` [hooks](https://www.npmjs.com/package/hooks-fixed).\r\nNormally this is used to do additional validation pre save, and cleanup post document removal. Although the hooks can be\r\nsetup for any method including `toObject` and `toJON` methods.\r\n\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  firstName: String,\r\n  lastName: String,\r\n  email: String\r\n});\r\n\r\nuserSchema.pre('save', function (next) {\r\n  if (this.email) {\r\n    this.email = this.email.toLowerCase();\r\n  }\r\n\r\n  // we must call next to continue control flow \r\n  next();\r\n});\r\n\r\nuserSchema.post('remove', function () {\r\n  console.log('document %s removed', this.id);\r\n});\r\n```\r\n\r\nImportant note here is that post 'save' and 'remove' hooks do not receive any form of control flow. There are no\r\ncallbacks passed.\r\n\r\nThe callback passed into pre hooks have be used to control flow of logic and execution:\r\n\r\n```js\r\nschema.pre('save', function (next) {\r\n  // some custom validation method\r\n  if (!this.validate()) {\r\n    return next(new Error('Validation error!'));\r\n  }\r\n \r\n  next();\r\n});\r\n\r\n// elsewhere...\r\n\r\ndoc.save(function(err, savedDoc) {\r\n  if(err) console.log(err); // 'Validation error!' Document was not saved\r\n});\r\n```\r\n\r\n### Schema Extension <a id=\"schema-extend\"></a>\r\n\r\nIt is useful to have a common base schema, that all other schemas / models would extend or \"inherit\" properties from.\r\nThis can be accomplished by using the `Schema.extend` function. When used all properties, virtuals,\r\nmethods, statics, and middleware that are present in the base schema **but not** present in destination schema are copied \r\ninto the destination schema.\r\n\r\n```js\r\n var baseSchema = lounge.schema({\r\n  metadata: {\r\n    doc_type: String,\r\n    createdAt: Date,\r\n    updatedAt: Date\r\n  }\r\n});\r\n\r\nbaseSchema.pre('save', function (next) {\r\n  if (!this.metadata) {\r\n    this.metadata = {};\r\n  }\r\n\r\n  var now = new Date();\r\n\r\n  if (!this.metadata.createdAt) {\r\n    this.metadata.createdAt = now;\r\n  }\r\n\r\n  this.metadata.updatedAt = now;\r\n  this.metadata.doc_type = this.modelName;\r\n\r\n  next();\r\n});\r\n\r\nbaseSchema.method('baseFoo', function () {\r\n  console.log('base foo');\r\n});\r\n\r\nvar userSchema = lounge.schema({\r\n  name: String,\r\n  email: String,\r\n});\r\n\r\nuserSchema.pre('save', function (next) {\r\n  if (this.email) {\r\n    this.email = this.email.toLowerCase();\r\n  }\r\n\r\n  next();\r\n});\r\n\r\nuserSchema.method('userFoo', function () {\r\n  console.log('user foo');\r\n});\r\n\r\n// make user schema extend the base schema \r\nuserSchema.extend(baseSchema);\r\nvar User = lounge.model('User', userSchema);\r\n\r\nuser = new User({\r\n  name: 'Bob Smith',\r\n  email: 'BSmith@gmail.com'\r\n});\r\n\r\nuser.baseFoo() // prints 'base foo'\r\nuser.userFoo() // prints 'user foo'\r\n\r\nuser.save(function(err, savedDoc) {\r\n  console.log(user.metadata.updatedAt); // Sat Dec 29 2015 03:30:00 GMT-0400 (AST)\r\n  console.log(user.metadata.doc_type); // 'user'\r\n  console.log(user.email); // 'bsmith@gmail.com'\r\n});\r\n```\r\n\r\n### Embedded Documents <a id=\"embedded\"></a>\r\n\r\nLounge allows for embedding and referencing other Models within schema.\r\n\r\n```js\r\nvar addressSchema = lounge.schema({\r\n  street: String,\r\n  city: String,\r\n  country: String\r\n});\r\n\r\nvar Address = lounge.model('Address', addressSchema);\r\n\r\nvar blogPostSchema = lounge.schema({\r\n  title: String,\r\n  body: String,\r\n});\r\n\r\nvar BlogPost = lounge.model('BlogPost', blogPostSchema);\r\n\r\nvar userSchema = lounge.schema({\r\n  name: String,\r\n  address: Address,\r\n  posts: [BlogPost]\r\n});\r\n\r\nvar post = new BlogPost({\r\n  title: 'Foo',\r\n  body: 'Lorem ipsum'\r\n});\r\n\r\nvar user = new User({\r\n  name: 'Bob Smith',\r\n  posts: [post],\r\n  address: new Address({\r\n    street: '123 Fake Street',\r\n    city: 'Springfield',\r\n    country: 'USA'\r\n  })\r\n});\r\n\r\nuser.posts.push(new BlogPost({\r\n  title: 'Post 2',\r\n  body: 'Some more text!'\r\n});\r\n```\r\n\r\nYou can manipulate and work with subdocument just like any model instances. When the top level document is saved\r\nall child subdocuments are saved as well. Subdocuments **must** be an instance of the Model defined in the schema or a \r\n`String` in which case it represents the key / id of the subdocument.\r\n\r\n### Saving Documents <a id=\"saving\"></a>\r\n\r\nSaving documents is done using `save` function that every model instance has. This will execute all pre \r\n'save' middleware and then perform Couchbase `upsert` operation on any subdocuments and the actual document. It will also\r\nperform lookup document updates and finally execute any post hook middleware.\r\n\r\nFrom our example code above:\r\n\r\n```js\r\nuser.save(function(err, savedDoc) {\r\n  if(err) console.log(err);\r\n});\r\n```\r\n\r\nAll documents and subdocuments would be upserted into the database.\r\n\r\n**Model.save(data, options, fn)**\r\n\r\n`data` - any data to be set into the model before saving.\r\n\r\n**options**\r\n\r\nAll options not present here are first looked up from schema options, and then from config options.\r\n* `storeFullReferenceId` - whether to save embedded document property values as full document keys or just the base value\r\n* `storeFullKey` - whether to save the internal document key property as fully expanded value or as the simple value\r\n* `refIndexKeyPrefix` - lookup index document key prefix.\r\n* `waitForIndex` - whether we want to wait for indexing to finish before returning. default is false.\r\n* `virtuals` - whether we want to save virtuals. default is `false`.\r\n* `minimize` - to \"minimize\" the document by removing any empty properties. Default: `true`\r\n* `expiry` - couchbase upsert option\r\n* `persist_to` - couchbase persist_to option\r\n* `replicate_to` - couchbase option\r\n \r\n### Getting Documents <a id=\"getting\"></a>\r\n\r\nAll models created come with a static function `findById` that can be used to look up a single or multiple keys and \r\nretrieve documents from the database. If key does not exist and document is not found we **do not** return an error\r\nbut also no model is generated. This is different than present couchbase module behaviour.\r\n\r\n```js\r\nUser.findById('user123', function(err, doc) {\r\n  if(err) console.log(err); // there was an error looking up the key\r\n  else if(!doc) console.log('no document found');\r\n  else console.log(doc); // doc is instance of User and will print it out \r\n});\r\n```\r\n\r\nWe can get multiple keys using an array as the first parameter. In this case, the callback invoked is passed 3 arguments\r\nin form `(err, documents, misses)`. \r\n\r\n```js\r\nUser.findById(['user123', 'user456'], function(err, docs, misses) {\r\n  if(err) console.log(err); // there was an error looking up the key\r\n  console.dir(docs);        // array of Users found\r\n  console.dir(misses);      // array if keys not found.\r\n});\r\n```\r\n\r\nWhen `findById` is invoked using a single string argument the result returned is a single model instance. When an array\r\nis passed in we return the results as described above. To force \"array\" type of returns in ALL cases, set the Lounge\r\nconfig option `alwaysReturnArrays` to `true`. Default is `false`.\r\n\r\n### Population <a id=\"population\"></a>\r\n\r\n`findById` comes with an options parameter that can have one property `populate` that can be used to dictate \r\nif and how we want to get any embedded subdocuments from the database. If `populate` option is `true` all embedded \r\nsubdocuments are retrieved from the database.\r\n \r\nFrom our \"Embedded Documents\" example, if we were to retrieve the user document created:\r\n\r\n```js\r\nUser.findById(userId, {populate: true}, function(err, doc) {\r\n  console.log(user instanceof User); // true\r\n  console.log(user.address instanceof Address); // true\r\n  console.log(user.posts[0] instanceof BlogPost); // true\r\n  \r\n  console.log(user); // full user document with retrieved address and posts subdocuments\r\n});\r\n```\r\n\r\nWe can specify a single field to populate:\r\n\r\n```js\r\nUser.findById(userId, {populate: 'address'}, function(err, doc) {\r\n  console.log(user instanceof User); // true\r\n  console.log(user.address instanceof Address); // true\r\n  console.log(user.posts[0] instanceof BlogPost); // false \r\n  console.log(user.posts[0] instanceof String); // true - posts is an array of string keys\r\n});\r\n```\r\n\r\n```js\r\nUser.findById(userId, {populate: 'posts'}, function(err, doc) {\r\n  console.log(user instanceof User); // true\r\n  console.log(user.address instanceof Address); // false\r\n  console.log(user.posts[0] instanceof BlogPost); // true\r\n});\r\n```\r\n\r\nWe can explicitly specify array indexes to populate\r\n\r\n```js\r\nUser.findById(userId, {populate: 'posts.1'}, function(err, doc) {\r\n  console.log(user instanceof User); // true\r\n  console.log(user.address instanceof Address); // false\r\n  console.log(user.posts[0] instanceof BlogPost); // false\r\n  console.log(user.posts[0] instanceof String); // true\r\n  console.log(user.posts[1] instanceof BlogPost); // true - fully populated\r\n});\r\n```\r\n\r\nFinally, `populate` can accept an array if fields to populate:\r\n \r\n```js\r\nUser.findById(userId, {populate: ['address', 'posts.1']}, function(err, doc) {\r\n  console.log(user instanceof User); // true\r\n  console.log(user.address instanceof Address); // true - fully populated\r\n  console.log(user.posts[0] instanceof BlogPost); // false\r\n  console.log(user.posts[0] instanceof String); // true\r\n  console.log(user.posts[1] instanceof BlogPost); // true - fully populated\r\n});\r\n```\r\n\r\n### Removing Documents <a id=\"removing\"></a>\r\n\r\nRemoving documents is done using `remove` function that every model instance has. This will execute all pre \r\n'remove' middleware and then perform Couchbase `remove` operation. It will also perform lookup document updates \r\nand finally execute any post hook middleware. By default this function **does not** remove embedded documents. To do\r\nthis set `removeRefs` options to `true`.\r\n\r\n```js\r\nuser.remove(function(err, doc) {\r\n  if(err) console.log(err);\r\n});\r\n```\r\n\r\nIf we want all subdocuments to be removed:\r\n\r\n```js\r\nuser.remove(function(err, {removeRefs: true}, doc) {\r\n  if(err) console.log(err);\r\n});\r\n```\r\n\r\nThis will execute removal, hooks and indexing operations for all documents and subdocuments.\r\n\r\n### Indexes <a id=\"indexes\"></a>\r\n\r\nLounge provides Indexing mechanism using [reference lookup documents](http://docs.couchbase.com/developer/dev-guide-3.0/lookups.html).\r\nThis allows us to set up simple one to one lookups for easier document retrieval where we do not need to do create view\r\nindexes. Specifying an index property is done at schema level:\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  name: String,\r\n  email: {type: String, index: true}\r\n});\r\n```\r\n\r\nHere we wish `User` models to have their own `id` as document key, but we want to be able to look up documents via email\r\nas well as that is also unique property for users. Lounge will automatically manage (remove and upsert) lookup documents,\r\nas user is `saved` or `removed`. \r\n \r\n```js\r\nvar user = new User({\r\n  name: 'Joe Smith',\r\n  email: 'joe@gmail.com'\r\n});\r\n\r\nuser.save();\r\n```\r\n\r\nThis will create the a lookup document similar to:\r\n\r\n```\r\n{ key: '2ba8a471-063b-420a-aa83-31debe58f46f' }\r\n```\r\n\r\nwith document key `'$_ref_by_email_joe@gmail.com'`. We can manipulate this behaviour using schema options.\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  name: String,\r\n  email: {type: String, index: true}\r\n}, {\r\n  keyPrefix: 'user::',\r\n  delimiter: '::'\r\n});\r\n```\r\n\r\nSaving a document defined with this schema will save user document with key `'user::5c4bfd6d-9c80-452b-be3a-3e528e4f53f5'`\r\nand will save a lookup document with key `''user::$_ref_by_email::joe@gmail.com'`. Setting `refIndexKeyPrefix` can add\r\nadditional customization.\r\n\r\n```js\r\n{\r\n  keyPrefix: 'user::',\r\n  delimiter: '::',\r\n  refIndexKeyPrefix: 'lookup_by_'\r\n}\r\n```\r\nThis will result in lookup document key `user::lookup_by_email::joe@gmail.com`.\r\n\r\nIndexes can also be arrays:\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  name: String\r\n  usernames: [{type: String, index: true}]\r\n});\r\n```\r\n\r\nA lookup document will be generated for each value in the array. Index lookup properties have to be of type `String` or\r\n`Number`.\r\n\r\nIndex lookup documents are automatically managed by lounge when documents are saved and removed using `save()` and\r\n`remove()` functions. You can also manually kick of this process by calling `index()` function on any model instance.\r\n\r\n### Index queries <a id=\"queries\"></a>\r\n\r\nAny indexed property the Model will automatically get a `findBy*` static function for easier lookup. \r\nFor example code above:\r\n\r\n```js\r\nvar User = lounge.model('User', userSchema);\r\n\r\nUser.findByEmail('joe@gmail.com', function(err, doc) {\r\n  if(err) console.log(err);\r\n  else console.log(doc);\r\n});\r\n```\r\n\r\nWe automatically singularize and camelize property key to derive the index name. So `usernames` becomes `findByUsername`.\r\nWe can specify the index \"name\" by passing along the `indexName` property. For example:\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  name: String\r\n  usernames: [{type: String, index: true, indexName: 'UN'}]\r\n});\r\n\r\nvar User = lounge.model('User', userSchema);\r\n\r\nUser.findByUN('user1', function(err, doc) {\r\n  if(err) console.log(err);\r\n  else console.log(doc);\r\n});\r\n```\r\n\r\n### Events <a id=\"events\"></a>\r\n\r\nAll model instances inherit [`EventEmitter`](https://nodejs.org/api/events.html#events_class_events_eventemitter), and \r\nemit three events:\r\n\r\n* `index` - when indexing of lookup documents finished regardless if successful or not. Emits `error` if there was any.\r\n* `save` - when the document was successfully saved.\r\n* `remove` - when the document was successfully removed.\r\n\r\n```js\r\nvar userSchema = lounge.schema({\r\n  name: String,\r\n  email: {type: String, index: true}\r\n});\r\n\r\nvar User = lounge.model('User', userSchema);\r\nvar user = new User({\r\n  name: 'Bob Smith',\r\n  email: 'bob@gmail.com'\r\n});\r\n\r\nuser.on('index', function (err) {\r\n  if(err) console.log('Error indexing document' + err.message);\r\n});\r\n\r\nuser.on('remove', function (doc) {\r\n  console.log('document removed');\r\n});\r\n\r\nuser.on('save', function (doc) {\r\n  console.log('document saved');\r\n});\r\n```\r\n\r\n## TESTS\r\n\r\nModule automated tests can be run using `npm test` command. The tests are executed using [Couchbase mocking](https://github.com/couchbase/couchnode#mock-testing).\r\nTo run tests against an actual local database create a bucket `lounge_test` and remove `LOUNGE_COUCHBASE_MOCK=true` from\r\n`test` script property in `package.json`.\r\n\r\n## TODO\r\n\r\nSee [TODO.md](https://github.com/bojand/lounge/blob/master/TODO.md).\r\n\r\n## Credits\r\n\r\nLots of code and design inspired by [Mongoose](http://mongoosejs.com/).\r\nUses modified version of [Draft](https://github.com/jwerle/draft) for schema and modelling.\r\n\r\n## License\r\n\r\nCopyright 2015 Bojan Djurkovic\r\n\r\nLicensed under the MIT License.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}